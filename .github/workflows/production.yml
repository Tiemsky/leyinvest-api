name: Production Deployment

on:
  push:
    branches: [ main ]
  workflow_dispatch:
    inputs:
      skip_tests:
        description: 'Skip tests (emergency deployment only)'
        required: false
        default: 'false'

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  test:
    runs-on: ubuntu-latest
    if: github.event.inputs.skip_tests != 'true'

    services:
      postgres:
        image: postgres:16-alpine
        env:
          POSTGRES_DB: laravel_test
          POSTGRES_USER: laravel
          POSTGRES_PASSWORD: secret
        ports:
          - 5432:5432
        options: >-
          --health-cmd pg_isready
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

      redis:
        image: redis:7-alpine
        ports:
          - 6379:6379
        options: >-
          --health-cmd "redis-cli ping"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup PHP
        uses: shivammathur/setup-php@v2
        with:
          php-version: '8.3'
          extensions: mbstring, dom, fileinfo, pgsql, redis
          coverage: xdebug

      - name: Copy .env
        run: php -r "file_exists('.env') || copy('.env.testing', '.env');"

      - name: Install Dependencies
        run: composer install --prefer-dist --no-progress --no-suggest --optimize-autoloader

      - name: Generate key
        run: php artisan key:generate

      - name: Directory Permissions
        run: chmod -R 777 storage bootstrap/cache

      - name: Run Tests
        env:
          DB_CONNECTION: pgsql
          DB_HOST: localhost
          DB_PORT: 5432
          DB_DATABASE: laravel_test
          DB_USERNAME: laravel
          DB_PASSWORD: secret
          REDIS_HOST: localhost
          REDIS_PORT: 6379
        run: php artisan test --coverage --min=80

      - name: Security Audit
        run: composer audit

  build:
    needs: test
    runs-on: ubuntu-latest
    if: always() && (needs.test.result == 'success' || needs.test.result == 'skipped')

    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=ref,event=branch
            type=sha,prefix=prod-
            type=semver,pattern={{version}}
            type=raw,value=production-latest

      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./docker/Dockerfile
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          build-args: |
            APP_ENV=production

  deploy:
    needs: build
    runs-on: ubuntu-latest
    environment: production

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.PROD_SSH_PRIVATE_KEY }}

      - name: Add server to known hosts
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ secrets.PROD_HOST }} >> ~/.ssh/known_hosts

      - name: Enable Maintenance Mode
        run: |
          ssh ${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }} << 'EOF'
            cd /var/www/production
            docker-compose -f docker-compose.prod.yml exec -T app php artisan down --retry=60 --secret="${{ secrets.MAINTENANCE_SECRET }}"
            echo "ðŸ”’ Maintenance mode enabled"
          EOF

      - name: Create Production Backup
        run: |
          ssh ${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }} << 'EOF'
            set -e

            BACKUP_DIR="/var/backups/laravel/production"
            TIMESTAMP=$(date +%Y%m%d_%H%M%S)
            APP_DIR="/var/www/production"
            RETENTION_DAYS=30

            # Create backup directory
            mkdir -p $BACKUP_DIR

            echo "ðŸ—„ï¸  Creating database backup..."
            docker exec production_postgres pg_dump -U ${{ secrets.PROD_DB_USER }} -Fc ${{ secrets.PROD_DB_NAME }} > $BACKUP_DIR/db_${TIMESTAMP}.dump

            echo "ðŸ“ Backing up storage and uploads..."
            tar -czf $BACKUP_DIR/storage_${TIMESTAMP}.tar.gz -C $APP_DIR storage/app

            echo "âš™ï¸  Backing up environment configuration..."
            cp $APP_DIR/.env $BACKUP_DIR/env_${TIMESTAMP}.backup

            # Upload to S3 or remote backup location (optional)
            # aws s3 cp $BACKUP_DIR/db_${TIMESTAMP}.dump s3://your-backup-bucket/production/

            echo "ðŸ§¹ Cleaning backups older than ${RETENTION_DAYS} days..."
            find $BACKUP_DIR -name "db_*.dump" -mtime +$RETENTION_DAYS -delete
            find $BACKUP_DIR -name "storage_*.tar.gz" -mtime +$RETENTION_DAYS -delete
            find $BACKUP_DIR -name "env_*.backup" -mtime +$RETENTION_DAYS -delete

            echo "âœ… Backup completed: ${TIMESTAMP}"
            echo "BACKUP_TIMESTAMP=${TIMESTAMP}" >> $GITHUB_ENV
          EOF

      - name: Deploy to Production Server
        run: |
          ssh ${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }} << 'EOF'
            set -e

            cd /var/www/production

            # Login to GitHub Container Registry
            echo ${{ secrets.GITHUB_TOKEN }} | docker login ghcr.io -u ${{ github.actor }} --password-stdin

            # Pull latest image
            echo "ðŸ“¦ Pulling latest image..."
            docker-compose -f docker-compose.prod.yml pull

            # Stop application (keeping database running)
            echo "â¸ï¸  Stopping application containers..."
            docker-compose -f docker-compose.prod.yml stop app nginx

            # Start new version
            echo "ðŸš€ Starting new version..."
            docker-compose -f docker-compose.prod.yml up -d

            # Wait for application to be ready
            echo "â³ Waiting for application to start..."
            sleep 15

            # Run migrations with backup
            echo "ðŸ”„ Running database migrations..."
            docker-compose -f docker-compose.prod.yml exec -T app php artisan migrate --force

            # Clear and optimize caches
            echo "ðŸ”§ Optimizing application..."
            docker-compose -f docker-compose.prod.yml exec -T app php artisan optimize:clear
            docker-compose -f docker-compose.prod.yml exec -T app php artisan config:cache
            docker-compose -f docker-compose.prod.yml exec -T app php artisan route:cache
            docker-compose -f docker-compose.prod.yml exec -T app php artisan view:cache
            docker-compose -f docker-compose.prod.yml exec -T app php artisan event:cache

            # Restart queue workers gracefully
            echo "ðŸ”„ Restarting queue workers..."
            docker-compose -f docker-compose.prod.yml exec -T app php artisan queue:restart

            # Restart scheduler if needed
            docker-compose -f docker-compose.prod.yml restart scheduler

            echo "âœ… Deployment completed!"
          EOF

      - name: Smoke Tests
        run: |
          echo "ðŸ§ª Running smoke tests..."

          # Test main endpoint
          response=$(curl -s -o /dev/null -w "%{http_code}" https://${{ secrets.PROD_DOMAIN }}/health || echo "000")
          if [ "$response" != "200" ]; then
            echo "âŒ Health check failed with status: $response"
            exit 1
          fi

          # Test API endpoint
          api_response=$(curl -s -o /dev/null -w "%{http_code}" https://${{ secrets.PROD_DOMAIN }}/api/health || echo "000")
          if [ "$api_response" != "200" ]; then
            echo "âŒ API health check failed with status: $api_response"
            exit 1
          fi

          # Test database connectivity
          ssh ${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }} << 'EOF'
            docker-compose -f /var/www/production/docker-compose.prod.yml exec -T app php artisan db:show
          EOF

          echo "âœ… All smoke tests passed!"

      - name: Disable Maintenance Mode
        if: success()
        run: |
          ssh ${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }} << 'EOF'
            cd /var/www/production
            docker-compose -f docker-compose.prod.yml exec -T app php artisan up
            echo "ðŸ”“ Maintenance mode disabled"
          EOF

      - name: Notify Success
        if: success()
        run: |
          echo "âœ… Production deployment successful!"
          # Add notification webhook here (Slack, Discord, PagerDuty, etc.)
          # curl -X POST -H 'Content-type: application/json' \
          #   --data '{"text":"âœ… Production deployed successfully!"}' \
          #   ${{ secrets.SLACK_WEBHOOK_URL }}

  rollback:
    runs-on: ubuntu-latest
    if: failure()
    needs: [deploy]

    steps:
      - name: Emergency Rollback
        run: |
          ssh ${{ secrets.PROD_USER }}@${{ secrets.PROD_HOST }} << 'EOF'
            set -e

            cd /var/www/production

            # Find latest backup
            LATEST_DB=$(ls -t /var/backups/laravel/production/db_*.dump | head -n1)
            LATEST_STORAGE=$(ls -t /var/backups/laravel/production/storage_*.tar.gz | head -n1)

            echo "ðŸ”™ EMERGENCY ROLLBACK INITIATED..."

            # Enable maintenance mode
            docker-compose -f docker-compose.prod.yml exec -T app php artisan down || true

            # Restore database
            echo "ðŸ—„ï¸  Restoring database from: $LATEST_DB"
            docker exec -i production_postgres pg_restore -U ${{ secrets.PROD_DB_USER }} -d ${{ secrets.PROD_DB_NAME }} --clean < $LATEST_DB

            # Restore storage
            echo "ðŸ“ Restoring storage from: $LATEST_STORAGE"
            tar -xzf $LATEST_STORAGE -C /var/www/production

            # Rollback to previous Docker image
            echo "ðŸ³ Rolling back Docker images..."
            docker-compose -f docker-compose.prod.yml down
            docker-compose -f docker-compose.prod.yml up -d --force-recreate

            # Clear caches
            sleep 10
            docker-compose -f docker-compose.prod.yml exec -T app php artisan optimize:clear

            # Disable maintenance mode
            docker-compose -f docker-compose.prod.yml exec -T app php artisan up

            echo "âœ… Rollback completed!"
          EOF

      - name: Notify Failure
        if: always()
        run: |
          echo "âŒ Production deployment failed - Rollback executed!"
          # Add critical alert notification here
          # curl -X POST -H 'Content-type: application/json' \
          #   --data '{"text":"ðŸš¨ CRITICAL: Production deployment failed! Rollback executed."}' \
          #   ${{ secrets.SLACK_WEBHOOK_URL }}
